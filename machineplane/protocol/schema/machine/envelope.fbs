namespace beemesh.machine;

// Envelope wraps any payload bytes with signature metadata so consumers can
// verify authenticity and origin without needing to parse the inner payload.
// The canonical bytes to be signed are the FlatBuffer bytes produced when
// sig and pubkey are empty strings. Verification should reconstruct the same
// canonical buffer (sig and pubkey empty) before calling into the crypto
// verify helpers.

table Envelope {
  // Raw payload bytes (e.g., inner FlatBuffer or encrypted JSON bytes)
  payload: [ubyte];

  // Optional type hint for the payload (e.g., "apply_request.v1")
  payload_type: string;

  // Nonce for replay mitigation (base64 or ascii)
  nonce: string;

  // Millisecond epoch timestamp
  ts: ulong;

  // Signature algorithm identifier (e.g., "ml-dsa-65")
  alg: string;

  // Signature string. For compatibility with existing code, we allow scheme prefix
  // like "ml-dsa-65:BASE64_SIG" but verification should parse and decode
  // the underlying BASE64_SIG as raw signature bytes.
  sig: string;

  // Base64-encoded public signing key bytes
  pubkey: string;

  // Optional peer id string (libp2p peer id) for convenience
  peer_id: string;

  // KEM public key for encryption (allows recipients to encrypt responses)
  kem_pubkey: string;
}

root_type Envelope;
