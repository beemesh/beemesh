namespace beemesh.machine;

// Signature scheme used to sign the manifest record
enum SignatureScheme:byte {
  NONE = 0,
  ED25519 = 1,
  RSA_PSS = 2
}

// Simple key/value pair helpful for labeling or small indexes
table KeyValue {
  key:string;
  value:string;
}

// Operation performed with this manifest record
enum OperationType:byte {
  APPLY = 0,
  UPDATE = 1,
  DELETE = 2
}

// AppliedManifest is the object stored in the DHT representing an applied
// Kubernetes manifest. It is designed to be verifiable (signature + pubkey),
// multi-tenant friendly (tenant + owner_pubkey) and retrievable via a stable
// identifier (`id` / `content_hash`).
table AppliedManifest {
  // A canonical identifier for this record. We recommend computing this as
  // the hex-encoded SHA-256 over a canonicalized payload (for example:
  // SHA256(tenant + ':' + operation_id + ':' + canonical_manifest)).
  // Storing it here avoids recalculating it when scanning or indexing.
  id:string;

  // Tenant or namespace used by the application to separate multi-tenant data.
  tenant:string;

  // An operation id supplied by the originator (also stored in ApplyRequest).
  // This can be used to correlate apply requests and responses.
  operation_id:string;

  // libp2p peer id of the origin that applied the manifest.
  origin_peer:string;

  // Raw public key bytes of the owner. Use this to verify `signature`.
  // Storing raw bytes keeps it compact and avoids encoding differences.
  owner_pubkey:[ubyte];

  // Algorithm / scheme used for the signature.
  signature_scheme:SignatureScheme = NONE;

  // Binary signature over the canonicalized data (see verification notes).
  signature:[ubyte];

  // The manifest itself. We keep JSON as a single string here for simplicity
  // and because most codepaths already operate on JSON. Consider storing a
  // canonicalized (sorted keys) JSON string for stable hashing/signing.
  manifest_json:string;

  // Optional convenience fields to make indexing and quick queries easier.
  manifest_kind:string;
  labels:[KeyValue];

  // Unix timestamp in milliseconds when this manifest was applied/signed.
  timestamp:uint64;

  // What kind of operation this record represents.
  operation:OperationType = APPLY;

  // Optional TTL (in seconds) to help nodes expire records from the DHT.
  ttl_secs:uint32 = 0;

  // Hex-encoded SHA-256 of the canonicalized manifest_json (content id).
  // Useful when you want a content-addressable reference to the manifest
  // independent of tenant or operation_id.
  content_hash:string;
}

root_type AppliedManifest;
