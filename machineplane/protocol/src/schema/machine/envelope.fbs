namespace beemesh.machine;

// Envelope wraps any payload bytes with signature metadata so consumers can
// verify authenticity and origin without needing to parse the inner payload.
// The canonical bytes to be signed are the FlatBuffer bytes produced when
// sig and pubkey are empty strings. Verification should reconstruct the same
// canonical buffer (sig and pubkey empty) before calling into the crypto
// verify helpers.

table Envelope {
  // Raw payload bytes (e.g., inner FlatBuffer or encrypted JSON bytes)
  payload: [ubyte];

  // Optional type hint for the payload (e.g., "apply_request.v1")
  payload_type: string;

  // Nonce for replay mitigation (base64 or ascii)
  nonce: string;

  // Millisecond epoch timestamp
  ts: ulong;

  // Signature algorithm identifier (e.g., "ml-dsa-65")
  alg: string;

  // Signature string. For compatibility with existing code, we allow scheme prefix
  // like "ml-dsa-65:BASE64_SIG" but verification should parse and decode
  // the underlying BASE64_SIG as raw signature bytes.
  sig: string;

  // Base64-encoded public key bytes
  pubkey: string;

  // Optional base64-encoded KEM public key bytes (raw ml_kem_512 bytes).
  // This field is optional and may be omitted. When present, callers SHOULD
  // ensure the KEM public key is integrity-protected by the envelope signature
  // (i.e., included in the canonical bytes signed by the sender) before using
  // it for encryption-related operations.
  kem_pub: string;

  // Optional peer id string (libp2p peer id) for convenience
  peer_id: string;
}

root_type Envelope;
